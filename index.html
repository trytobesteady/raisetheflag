<html lang="en">

	<head>
		<title>three.js canvas - combo camera - orthographic + perspective</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<link rel="stylesheet" href="css/main.css">

	</head>

	<body>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.0/TweenMax.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.min.js"></script>

		<script src="lib/OrbitControls.js"></script>
		<script src="lib/CombinedCamera.js"></script>
		<script src="lib/Projector.js"></script>
		<script src="lib/CanvasRenderer.js"></script>
		<script src="lib/stats.min.js"></script>

		<script type="text/javascript" src="js/chat.js"></script>
		<script type="text/javascript" src="js/script.js"></script>


		<div style="position: absolute; top: 10px; width: 100%; text-align: center; ">
			<h2 id="game-message">Placement Phase: <br>Place Your Pieces Anywhere On The Board.</h2>
			<h2 id="error-message"></h2>
			<button id="button-next">START</button>
		</div>

		<div class="container">
			<div class="chat">
				<form onsubmit="chat.sendMsg(); return false;">
					<input type="text" id="msg" name="msg" autofocus="true" placeholder="Type Your Message Here" />
					<input type="submit" />
				</form>
				<div id="chatZone" name="chatZone"></div>
			</div>
		</div>



		<script>
			var container, stats;
			var mouse = new THREE.Vector2(), INTERSECTED;
			var camera, controls, raycaster, scene, renderer;
			var playerOneA, playerOneB, playerTwoA, playerTwoB;
			var currentGameObject;
			var currentPlayerPiece;
			var boxSize = 200;
			var lookAtScene = true;
			var gameMessageDomObject;
			var errorMessageDomObject;
			var buttonNext;
			var gameMessages = ['0 Placement Phase: <br>Place Your Pieces Anywhere On The Board.',
													'1 Red Turn: Move',
													'2 Red Turn: Build',
													'3 Blue Turn: Move',
													'4 Blue Turn: Build',
													'5 Win']
			var playerBlockedTiles = [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1], [-1, -1, -1]];

			var gameState = 0;	//0: Placement, 1: TurnRed Move, 2: TurnRed Build, 3: TurnBlue Move, 4: TurnBlue Build, 5: End

			var availableMovesRed = 1;
			var availableMovesBlue = 1;

			var layerColors = [0xfee4a2, 0xfdfac2, 0xd9d746, 0xf7f461];

			var lightHelper;


			//var playerOneCurrentPiece = -1;
			//var playerTwoCurrentPiece = -1;

			$( document ).ready(function() {
				init();
				animate();
			});

			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				gameMessageDomObject = $('#game-message');
				errorMessageDomObject = $('#error-message');
				buttonNext = $('#button-next')[0];

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1 , 1000000);
				camera.position.x = 2000;
				camera.position.y = 2000;
				camera.position.z = 2000;

				scene = new THREE.Scene();

				// Zero
				var geometry = new THREE.BoxGeometry( 10, 10, 10 );
				var material = new THREE.MeshPhongMaterial( {color: 0x00ff00} );
				var cube = new THREE.Mesh( geometry, material );
				cube.position.x = 500;
				cube.position.y = 110;
				cube.position.z = 500;
				cube.receiveShadow = true;
				//scene.add( cube );

				// Grid
				var gridSize = 500;
				var divisions = 5;
				var gridHelper = new THREE.GridHelper( gridSize, divisions );
				gridHelper.position.x = 500;
				gridHelper.position.y = 15;
				gridHelper.position.z = 500;
				gridHelper.userData.id = 'grid';
				//scene.add( gridHelper );

				//Player
				var playerGeometry = new THREE.CylinderBufferGeometry( 50, 50, 100, 32 );
				//var playerGeometry = new THREE.planeGeometry( 50, 100, 50, 1, 1, 1);
				var materialRedA = new THREE.MeshPhongMaterial( {color: 0xFF0000} );
				var materialRedB = new THREE.MeshPhongMaterial( {color: 0xFF0000} );
				playerOneA = new THREE.Mesh( playerGeometry, materialRedA );
				playerOneB = new THREE.Mesh( playerGeometry, materialRedB );
				playerOneA.userData.type ='playerpiece';
				playerOneA.userData.color ='red';
				playerOneA.userData.id = 0;
				playerOneA.userData.pos = [-1, -1, -1];
				playerOneA.position.x = -200;
				playerOneA.position.y = 100;
				playerOneA.position.z = 50;
				playerOneA.castShadow = true;
				playerOneA.receiveShadow = true;
				scene.add( playerOneA );

				playerOneB.userData.type ='playerpiece';
				playerOneB.userData.color ='red';
				playerOneB.userData.id = 1;
				playerOneB.userData.pos = [-1, -1, -1];
				playerOneB.position.x = -200;
				playerOneB.position.y = 100;
				playerOneB.position.z = 200;
				playerOneB.castShadow = true;
				playerOneB.receiveShadow = true;
				scene.add( playerOneB );

				var materialBlueA = new THREE.MeshPhongMaterial( {color: 0x0000FF} );
				var materialBlueB = new THREE.MeshPhongMaterial( {color: 0x0000FF} );
				playerTwoA = new THREE.Mesh( playerGeometry, materialBlueA );
				playerTwoB = new THREE.Mesh( playerGeometry, materialBlueB );
				playerTwoA.userData.type ='playerpiece';
				playerTwoA.userData.color ='blue';
				playerTwoA.userData.id = 2;
				playerTwoA.userData.pos = [-1, -1, -1];
				playerTwoA.position.x = 1200;
				playerTwoA.position.y = 100;
				playerTwoA.position.z = 800;
				playerTwoA.castShadow = true;
				playerTwoA.receiveShadow = true;
				scene.add( playerTwoA );

				playerTwoB.userData.type ='playerpiece';
				playerTwoB.userData.color ='blue';
				playerTwoB.userData.id = 3;
				playerTwoB.userData.pos = [-1, -1, -1];
				playerTwoB.position.x = 1200;
				playerTwoB.position.y = 100;
				playerTwoB.position.z = 950;
				playerTwoB.castShadow = true;
				playerTwoB.receiveShadow = true;
				scene.add( playerTwoB );

				// Cubes
				var planeGeometry = new THREE.PlaneGeometry( boxSize, boxSize, 1 );
				var row = -1;
				var col = -1;
				var lay = 0;

				for ( var i = 0; i < 25; i ++ ) {
					var plane = new THREE.Mesh( planeGeometry, new THREE.MeshPhongMaterial( { color: layerColors[0] } ) );

					plane.userData.type ='gridpiece';
					// add new row when restless dividable by 5
					col++;
					if(i % 5 == 0) {
						row++;
						col = 0;
					}

					plane.userData.pos = [row, col, lay];

					var j = i % 5;
					plane.position.x = boxSize * j + boxSize/2;
					plane.position.y = 50;
					plane.position.z = boxSize * row + boxSize/2;
					plane.rotation.x = Math.PI / -2;
					plane.receiveShadow = true;
					scene.add(plane);
				}

				var boardCenter = new THREE.Object3D();
				boardCenter.position.set( 500, 100, 500 );
				scene.add(boardCenter);

				// Lights
				var ambient = new THREE.AmbientLight( 0x404040 ); // soft white light
				ambient.position.set( 0, 1500, 0 );
				ambient.intensity = 0.6;
				scene.add( ambient );

				var light = new THREE.SpotLight( 0xffffff, 1, 0, Math.PI / 2 );
				light.position.set( 1000, 1500, 1000 );
				light.castShadow = true;
				light.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 100, 3000 ) );
				light.shadow.bias = 0.0001;
				light.shadow.mapSize.width = 1024;
				light.shadow.mapSize.height = 1024;
				light.penumbra = 0.1;
				light.decay = 0;
				light.angle = Math.PI / 4;
				light.intensity = 0.4;
				light.distance = 3000;
				light.target = boardCenter;
				scene.add( light );


				raycaster = new THREE.Raycaster();
				//renderer = new THREE.CanvasRenderer();
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.gammaInput = true;
				renderer.gammaOutput = true;
				container.appendChild( renderer.domElement );

				lightHelper = new THREE.SpotLightHelper( light );
				scene.add( lightHelper );

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.target.set(500, 0, 500);

				stats = new Stats();
				container.appendChild( stats.dom );
				window.addEventListener( 'resize', onWindowResize, false );

				document.addEventListener( 'click', onClick, false );
				buttonNext.addEventListener('click', onButtonNext);
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			}

			function onWindowResize(){
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onClick( event ) {
				if(currentGameObject) {
					if(currentGameObject.userData != undefined) {
						checkGameState(currentGameObject);
					}
				}
			}

			function onButtonNext( event ) {
				event.preventDefault();

				if(allPiecesPlaced()) {
					$(event.currentTarget).css('opacity', 0);
					setGameState(1);
					resetHighlights();
					errorMessageDomObject.empty();
				} else {
					errorMessageDomObject.html('Not All Pieces Are Placed On The Board');
				}
			}

			function allPiecesPlaced() {
				var flag = true;
				for (var i = 0; i < playerBlockedTiles.length; i++) {
					for (var j = 0; j < playerBlockedTiles[i].length; j++) {
						if(playerBlockedTiles[i][j] == -1) {
							flag = false;
						}
					}
				}

				return flag;
			}

			function setGameState(state) {
				gameState = state;
				updateGameMessage(gameState);
			}

			function checkGameState(currentObject) {
				console.log(gameState, currentObject.userData);

				switch(gameState) {
					case 0:
						//PLACEMENT
						if(currentObject.userData.type == 'playerpiece') {
							currentPlayerPiece = currentObject;
							resetHighlights();
							if(currentObject.userData.id == 0) {
								playerOneA.material.color.setHex(0xffb4b4);
							} else if(currentObject.userData.id == 1) {
								playerOneB.material.color.setHex(0xffb4b4);
							} else if(currentObject.userData.id == 2) {
								playerTwoA.material.color.setHex(0xb4b6ff);
							} else if(currentObject.userData.id == 3) {
								playerTwoB.material.color.setHex(0xb4b6ff);
							}
						}

						//moving playerpiece to valid tilepiece
						if(currentObject.userData.type == 'gridpiece' && currentPlayerPiece) {
							if(isValidMove(currentPlayerPiece, currentGameObject, false)){
								moveToTile(currentPlayerPiece, currentGameObject);
							} else {
								//move invalid
							}
						}
						break;
					case 1:
						//resetting available moves
						noMovesLeft = false;
						availableMovesRed = 1;
						availableMovesBlue = 1;

						//RED: MOVE
						if(currentObject.userData.type == 'playerpiece' && currentObject.userData.color == 'red') {
							currentPlayerPiece = currentObject;
							resetHighlights();

							if(currentObject.userData.id == 0) {
								playerOneA.material.color.setHex(0xffb4b4);
							} else if(currentObject.userData.id == 1) {
								playerOneB.material.color.setHex(0xffb4b4);
							}
						}

						//moving playerpiece to valid tilepiece
						if(currentObject.userData.type == 'gridpiece' && currentPlayerPiece.userData.color == 'red') {
							if(isValidMove(currentPlayerPiece, currentGameObject, false)){
								moveToTile(currentPlayerPiece, currentGameObject);
							} else {
								//move invalid
							}
						}

						break;
					case 2:
						//RED: BUILD
						if(isValidMove(currentPlayerPiece, currentGameObject, true)){
							buildOnTile(currentPlayerPiece, currentGameObject);
						} else {
							//placement invalid
						}

						break;
					case 3:
						//BLUE: MOVE
						if(currentObject.userData.type == 'playerpiece' && currentObject.userData.color == 'blue') {
							resetHighlights();

							if(currentObject.userData.id == 2) {
								playerTwoA.material.color.setHex(0xb4b6ff);
								currentPlayerPiece = currentObject;
							} else if(currentObject.userData.id == 3) {
								playerTwoB.material.color.setHex(0xb4b6ff);
								currentPlayerPiece = currentObject;
							}
						}

						//moving playerpiece to valid tilepiece
						if(currentObject.userData.type == 'gridpiece' && currentPlayerPiece.userData.color == 'blue') {
							if(isValidMove(currentPlayerPiece, currentGameObject, false)){
								moveToTile(currentPlayerPiece, currentGameObject);
							} else {
								//move invalid
							}
						}

						break;
					case 4:
						//BLUE: BUILD
						if(isValidMove(currentPlayerPiece, currentGameObject, true)){
							buildOnTile(currentPlayerPiece, currentGameObject);
						} else {
							//placement invalid
						}

						break;
				}
			}

			function resetHighlights() {
				playerOneA.material.color.setHex(0xFF0000);
				playerOneB.material.color.setHex(0xFF0000);
				playerTwoA.material.color.setHex(0x0000FF);
				playerTwoB.material.color.setHex(0x0000FF);
			}

			function moveToTile(playerPiece, targetTile) {
				var newLayerIndex = targetTile.userData.pos[2]+1;
				var newHeight = newLayerIndex * boxSize/2;

				//bezier tween adjustments
				var bx, bz;
				var dim = 50;
				if(targetTile.position.x > playerPiece.position.x) {
					bx = playerPiece.position.x + dim;
				} else if(targetTile.position.x < playerPiece.position.x) {
					bx = playerPiece.position.x - dim;
				} else {
					bx = playerPiece.position.x;
				}

				if(targetTile.position.z > playerPiece.position.z) {
					bz = playerPiece.position.z + dim;
				} else if(targetTile.position.z < playerPiece.position.z) {
					bz = playerPiece.position.z - dim;
				} else {
					bz = playerPiece.position.z;
				}

				var playerLayer = playerPiece.userData.pos[2];
				var targetLayer = targetTile.userData.pos[2];

				if(playerLayer == targetLayer) {
					TweenMax.to(playerPiece.position, 0.5, { x:targetTile.position.x, z:targetTile.position.z, ease:Sine.easeInOut });
				} else if(playerLayer > targetLayer) {
					TweenMax.to(playerPiece.position, 0.5, {bezier:[{x:bx, y:newHeight+100, z:bz},
																													{x:targetTile.position.x, y:newHeight, z:targetTile.position.z}],
																													ease:Sine.easeInOut});
				} else if(playerLayer < targetLayer) {
					TweenMax.to(playerPiece.position, 0.5, {bezier:[{x:bx, y:newHeight+200, z:bz},
																													{x:targetTile.position.x, y:newHeight, z:targetTile.position.z}],
																													ease:Sine.easeInOut});
				}

				playerPiece.userData.pos = targetTile.userData.pos;
				updatePlayerBlockedTiles(playerPiece, targetTile);

				//red turn: allow only one move
				if(gameState == 1) {
					availableMovesRed--;
					if(availableMovesRed == 0) {
						setGameState(2);
					}
				}

				//blue turn: allow only one move
				if(gameState == 3) {
					availableMovesBlue--;
					if(availableMovesBlue == 0) {
						setGameState(4);
					}
				}

				//win condition
				if(newLayerIndex == 4) {
					setGameState(5);
					console.log(playerPiece.userData.color + ' wins!');
				}
			}

			function buildOnTile(playerPiece, targetTile) {
				resetHighlights();
				var newLayerIndex = targetTile.userData.pos[2]+1;
				var newHeight = newLayerIndex * boxSize/2;

				var geometry = new THREE.BoxGeometry( boxSize, boxSize/2, boxSize );
				var material = new THREE.MeshPhongMaterial( {color: layerColors[newLayerIndex]} );
				var newCube = new THREE.Mesh( geometry, material );

				console.log('B newHeight', targetTile.position.y, newLayerIndex);

				newCube.position.x = targetTile.position.x;
				newCube.position.y = newHeight;
				newCube.position.z = targetTile.position.z;

				newCube.userData.type = targetTile.userData.type;
				newCube.userData.pos = targetTile.userData.pos;

				//shift layer up one unit
				newCube.userData.pos[0] = targetTile.userData.pos[0];
				newCube.userData.pos[1] = targetTile.userData.pos[1];
				newCube.userData.pos[2] = newLayerIndex;
				newCube.castShadow = true;
				newCube.receiveShadow = true;
				scene.add( newCube );

				if(gameState != 4){
					setGameState(gameState+1);
				} else {
					setGameState(1);
				}
			}

			function updatePlayerBlockedTiles(playerPiece, targetTile) {
				var currentPlayerPieceId = playerPiece.userData.id;
				var currentTargetTileId = targetTile.userData.pos;

				playerBlockedTiles[currentPlayerPieceId] = [];
				playerBlockedTiles[currentPlayerPieceId].push(currentTargetTileId[0], currentTargetTileId[1], currentTargetTileId[2]);
			}

			function isValidMove(playerPiece, targetTile, isBuildMove) {
				//flags
				var allValid = true;
				var isTargetBlockedByPlayer = false;
				var isTargetNotAdjacent = false;
				var isTargetToHigh = false;
				var noMovesLeft = false;
				var isMaximumHeight = false;

				var startRow = playerPiece.userData.pos[0];
				var startCol = playerPiece.userData.pos[1];
				var startLay = playerPiece.userData.pos[2];

				var targetRow = targetTile.userData.pos[0];
				var targetCol = targetTile.userData.pos[1];
				var targetLay = targetTile.userData.pos[2];

				var deltaRow = Math.abs(startRow - targetRow);
				var deltaCol = Math.abs(startCol - targetCol);
				var deltaLay = Math.abs(startLay - targetLay);
				var absLay = startLay - targetLay;


				//extra rule for building UP (can build up to 3 layers)
				if(isBuildMove) {
					if(deltaRow > 1 || deltaCol > 1 || deltaLay > 4) {
						console.log('HIGH DISTANCE BUILDING');
						isTargetNotAdjacent = true;
					}
				} else {
					//check if move is within range
					if(deltaRow > 1 || deltaCol > 1 || deltaLay > 1) {
						isTargetNotAdjacent = true;

						if(absLay > 0) {
							console.log('JUMPING FROM A GREAT HEIGHT');
							isTargetNotAdjacent = false;
						}
					}
				}

				//check for maximum height
				if(targetLay > 3) {
					isMaximumHeight = true
				}

				//no range limit in placement phase
				if(gameState == 0) {
					isTargetNotAdjacent = false;
				}

				//check if a piece has moves left
				if(gameState == 1 && availableMovesRed == 0) {
					noMovesLeft = true;
				} else if(gameState == 3 && availableMovesBlue == 0) {
					noMovesLeft = true;
				}

				//check if another playerpiece is in the way
				for (var i = 0; i < playerBlockedTiles.length; i++) {
					if(targetRow == playerBlockedTiles[i][0] && targetCol == playerBlockedTiles[i][1] && targetLay == playerBlockedTiles[i][2]) {
						isTargetBlockedByPlayer = true;
					}
				}

				//sum up flags
				if(isTargetBlockedByPlayer || isTargetNotAdjacent || noMovesLeft || isMaximumHeight) {
					console.log('isBuildMove:', isBuildMove, ' isTargetBlockedByPlayer: ', isTargetBlockedByPlayer, ' isTargetNotAdjacent: ', isTargetNotAdjacent, ' noMovesLeft: ', noMovesLeft, ' isMaximumHeight: ',isMaximumHeight);
					allValid = false;
				}

				return allValid;
			}

			function updateGameMessage(id) {
				gameMessageDomObject.html(gameMessages[id]);
			}

			function onDocumentMouseMove( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}

			function animate() {
				requestAnimationFrame( animate );
				stats.begin();
				render();
				stats.end();
			}

			var dropInterval = 1;
			var increment = 0;
			var initialLookAt = true;

			function render() {
				lightHelper.update();

				increment++

				if (increment / dropInterval == 1) {
					increment = 0;

					if(initialLookAt) {
						camera.lookAt(new THREE.Vector3(500,0,500));
						initialLookAt = false;
					}



					// find intersections
					raycaster.setFromCamera( mouse, camera );
					var intersects = raycaster.intersectObjects( scene.children );
						if (intersects.length > 0) {
							if (INTERSECTED != intersects[0].object ) {
								if (INTERSECTED) {
									if(INTERSECTED.material.emissive) {
										INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
									}
								}

								INTERSECTED = intersects[0].object;
								currentGameObject = INTERSECTED;

								if(INTERSECTED.material.emissive) {
									INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
									INTERSECTED.material.emissive.setHex(0xff0000);
								}

							}
						} else {
							if (INTERSECTED) {
								if(INTERSECTED.material.emissive) {
									INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
								}
							}
							INTERSECTED = null;
							currentGameObject = null;
						}
					renderer.render( scene, camera );
				}
			}

		</script>

	</body>
</html>
