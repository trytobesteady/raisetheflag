<html lang="en">

	<head>
		<title>three.js canvas - combo camera - orthographic + perspective</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>

			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
				color: black;
			}

			a {
				color: red;
			}

		</style>
	</head>

	<body>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.0/TweenLite.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.min.js"></script>

		<script src="lib/OrbitControls.js"></script>
		<script src="lib/CombinedCamera.js"></script>
		<script src="lib/Projector.js"></script>
		<script src="lib/CanvasRenderer.js"></script>
		<script src="lib/stats.min.js"></script>

		<script src="js/scripts.js"></script>

		<div style="position: absolute; top: 10px; width: 100%; text-align: center; ">
			<h2 id=game-message>Placement Phase: <br>Place Your Pieces Anywhere On The Board.</h2>
			<button id="button-next">NEXT</button>
		</div>


		<script>
			var container, stats;
			var mouse = new THREE.Vector2(), INTERSECTED;
			var camera, controls, raycaster, scene, renderer;
			var playerOneA, playerOneB, playerTwoA, playerTwoB;
			var currentGameObject;
			var currentPlayerPiece;
			var boxSize = 200;
			var lookAtScene = true;
			var gameMessageDomObject;
			var buttonNext;
			var gameMessages = ['Placement Phase: <br>Place Your Pieces Anywhere On The Board.',
													'Red Turn: Move One Of Your Pieces To An Adjacent Tile',
													'Red Turn: Build A Structure On An Adjacent Tile (at any height)',
													'Blue Turn: Move',
													'Blue Turn: Build',
													'Win']
			var playerBlockedTiles = [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1], [-1, -1, -1]];

			var gameState = 0;	//0: Placement, 1: TurnRed Move, 2: TurnRed Build, 3: TurnBlue Move, 4: TurnBlue Build, 5: End

			var availableMovesRed = 1;
			var availableMovesBlue = 1;

			var layerColors = [0xfee4a2, 0xfdfac2, 0xd9d746, 0xf7f461];


			//var playerOneCurrentPiece = -1;
			//var playerTwoCurrentPiece = -1;

			$( document ).ready(function() {
				init();
				animate();
			});

			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				gameMessageDomObject = $('#game-message');
				buttonNext = $('#button-next')[0];

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1 , 1000000);
				camera.position.x = 1000;
				camera.position.y = 1000;
				camera.position.z = 1000;

				scene = new THREE.Scene();

				// Zero
				var geometry = new THREE.BoxGeometry( 1, 1000, 1 );
				var material = new THREE.MeshLambertMaterial( {color: 0x00ff00} );
				var cube = new THREE.Mesh( geometry, material );
				scene.add( cube );

				// Grid
				var gridSize = 500;
				var divisions = 5;
				var gridHelper = new THREE.GridHelper( gridSize, divisions );
				gridHelper.position.x = 500;
				gridHelper.position.y = 15;
				gridHelper.position.z = 500;
				gridHelper.userData.id = 'grid';
				//scene.add( gridHelper );

				//Player
				var playerGeometry = new THREE.CylinderBufferGeometry( 50, 50, 100, 8 );
				var materialRedA = new THREE.MeshLambertMaterial( {color: 0xFF0000} );
				var materialRedB = new THREE.MeshLambertMaterial( {color: 0xFF0000} );
				playerOneA = new THREE.Mesh( playerGeometry, materialRedA );
				playerOneB = new THREE.Mesh( playerGeometry, materialRedB );
				playerOneA.userData.type ='playerpiece';
				playerOneA.userData.id = 0;
				playerOneA.userData.pos = [-1, -1, -1];
				playerOneA.position.x = -200;
				playerOneA.position.y = 60;
				playerOneA.position.z = 50;

				playerOneB.userData.type ='playerpiece';
				playerOneB.userData.id = 1;
				playerOneB.userData.pos = [-1, -1, -1];
				playerOneB.position.x = -200;
				playerOneB.position.y = 60;
				playerOneB.position.z = 200;
				scene.add( playerOneA );
				scene.add( playerOneB );

				var materialBlueA = new THREE.MeshLambertMaterial( {color: 0x0000FF} );
				var materialBlueB = new THREE.MeshLambertMaterial( {color: 0x0000FF} );
				playerTwoA = new THREE.Mesh( playerGeometry, materialBlueA );
				playerTwoB = new THREE.Mesh( playerGeometry, materialBlueB );
				playerTwoA.userData.type ='playerpiece';
				playerTwoA.userData.id = 2;
				playerTwoA.userData.pos = [-1, -1, -1];
				playerTwoA.position.x = 1200;
				playerTwoA.position.y = 60;
				playerTwoA.position.z = 800;

				playerTwoB.userData.type ='playerpiece';
				playerTwoB.userData.id = 3;
				playerTwoB.userData.pos = [-1, -1, -1];
				playerTwoB.position.x = 1200;
				playerTwoB.position.y = 60;
				playerTwoB.position.z = 950;
				scene.add( playerTwoA );
				scene.add( playerTwoB );

				// Cubes
				var boxGeometry = new THREE.BoxGeometry( boxSize, boxSize/8, boxSize, 1, 1, 1);
				var row = -1;
				var col = -1;
				var lay = 0;

				for ( var i = 0; i < 25; i ++ ) {
					var cube = new THREE.Mesh( boxGeometry, new THREE.MeshLambertMaterial( { color: layerColors[0] } ) );

					cube.userData.type ='gridpiece';
					// add new row when restless dividable by 5
					col++;
					if(i % 5 == 0) {
						row++;
						col = 0;
					}

					cube.userData.pos = [row, col, lay];

					var j = i % 5;
					cube.position.x = boxSize * j + boxSize/2;
					cube.position.z = boxSize * row - boxSize/2;
					scene.add(cube);
				}

				// Lights
				var directionalLight = new THREE.DirectionalLight( 0xffffff );
				directionalLight.position.x = 1;
				directionalLight.position.y = 1;
				directionalLight.position.z = 0;
				directionalLight.position.normalize();
				directionalLight.intensity = 0.5;
				scene.add( directionalLight );

				raycaster = new THREE.Raycaster();

				//renderer = new THREE.CanvasRenderer();
				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.target.set(500, 0, 500);

				stats = new Stats();
				container.appendChild( stats.dom );
				window.addEventListener( 'resize', onWindowResize, false );

				document.addEventListener( 'click', onClick, false );
				buttonNext.addEventListener('click', onButtonNext);
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			}

			function onWindowResize(){
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onClick( event ) {
				if(currentGameObject) {
					if(currentGameObject.userData != undefined) {
						checkGameState(currentGameObject);
					}
				}
			}

			function onButtonNext( event ) {
				event.preventDefault();
				setGameState(1);
			}

			function setGameState(state) {
				gameState = state;

				updateGameMessage(gameState);

				switch(state) {
					case 0:
						resetHighlights();
						break;
					case 1:
						resetHighlights();
						break;
					case 2:
						break;
					case 3:
						break;
					case 4:
						break;
					case 5:
						break;
				}
			}

			function checkGameState(currentObject) {
				console.log(gameState, currentObject.userData);

				switch(gameState) {
					case 0:
						//PLACEMENT
						if(currentObject.userData.type == 'playerpiece') {
							resetHighlights();

							if(currentObject.userData.id == 0) {
								playerOneA.material.color.setHex(0xffb4b4);
							} else if(currentObject.userData.id == 1) {
								playerOneB.material.color.setHex(0xffb4b4);
							} else if(currentObject.userData.id == 2) {
								playerTwoA.material.color.setHex(0xb4b6ff);
							} else if(currentObject.userData.id == 3) {
								playerTwoB.material.color.setHex(0xb4b6ff);
							}
							currentPlayerPiece = currentObject;
						}

						//moving playerpiece to valid tilepiece
						if(currentObject.userData.type == 'gridpiece' && currentPlayerPiece) {
							if(isValidMove(currentPlayerPiece, currentGameObject)){
								moveToTile(currentPlayerPiece, currentGameObject);
							} else {
								//move invalid
							}
						}
						break;
					case 1:
						//RED: MOVE
						if(currentObject.userData.type == 'playerpiece') {
							playerOneA.material.color.setHex(0xFF0000);
							playerOneB.material.color.setHex(0xFF0000);
							playerTwoA.material.color.setHex(0x0000FF);
							playerTwoB.material.color.setHex(0x0000FF);

							if(currentObject.userData.id == 0) {
								playerOneA.material.color.setHex(0xffb4b4);
							} else if(currentObject.userData.id == 1) {
								playerOneB.material.color.setHex(0xffb4b4);
							}
							currentPlayerPiece = currentObject;
						}

						//moving playerpiece to valid tilepiece
						if(currentObject.userData.type == 'gridpiece' && currentPlayerPiece) {
							if(isValidMove(currentPlayerPiece, currentGameObject)){
								moveToTile(currentPlayerPiece, currentGameObject);
							} else {
								//move invalid
							}
						}

						break;
					case 2:
						//RED: BUILD

						if(isValidMove(currentPlayerPiece, currentGameObject)){
							buildOnTile(currentPlayerPiece, currentGameObject);
						} else {
							//placement invalid
						}

						break;
					case 3:
						break;
				}
			}

			function resetHighlights() {
				playerOneA.material.color.setHex(0xFF0000);
				playerOneB.material.color.setHex(0xFF0000);
				playerTwoA.material.color.setHex(0x0000FF);
				playerTwoB.material.color.setHex(0x0000FF);
			}

			function moveToTile(playerPiece, targetTile) {
				TweenLite.to(playerPiece.position, 1, {x:targetTile.position.x, z:targetTile.position.z})
				playerPiece.userData.pos = targetTile.userData.pos;
				updatePlayerBlockedTiles(playerPiece, targetTile);

				//red turn: allow only one move
				if(gameState == 1) {
					availableMovesRed--;
					if(availableMovesRed == 0) {
						setGameState(2);
					}
				}
			}

			function buildOnTile(playerPiece, targetTile) {
				//cube.userData.pos = [row, col, lay];
				var newLayerIndex = targetTile.userData.pos[2] + 1;

				var geometry = new THREE.BoxGeometry( boxSize, boxSize/2, boxSize );
				var material = new THREE.MeshLambertMaterial( {color: layerColors[newLayerIndex]} );
				var newCube = new THREE.Mesh( geometry, material );

				newCube.position.x = targetTile.position.x;
				newCube.position.y = targetTile.position.y + 20;
				newCube.position.z = targetTile.position.z;

				newCube.userData.type = targetTile.userData.type;
				newCube.userData.pos = targetTile.userData.pos;

				//shift layer up one unit
				newCube.userData.pos[0] = targetTile.userData.pos[0];
				newCube.userData.pos[1] = targetTile.userData.pos[1];
				newCube.userData.pos[2] = newLayerIndex;

				scene.add( newCube );

				setGameState(gameState+1);

			}

			function updatePlayerBlockedTiles(playerPiece, targetTile) {
				var currentPlayerPieceId = playerPiece.userData.id;
				var currentTargetTileId = targetTile.userData.pos;

				playerBlockedTiles[currentPlayerPieceId] = [];
				playerBlockedTiles[currentPlayerPieceId].push(currentTargetTileId[0], currentTargetTileId[1], currentTargetTileId[2]);
			}

			function isValidMove(playerPiece, targetTile) {
				//flags
				var allValid = true;
				var isTargetBlockedByPlayer = false;
				var isTargetNotAdjacent = false;
				var isTargetToHigh = false;
				var noMovesLeft = false;

				var startRow = playerPiece.userData.pos[0];
				var startCol = playerPiece.userData.pos[1];
				var startLay = playerPiece.userData.pos[2];

				var targetRow = targetTile.userData.pos[0];
				var targetCol = targetTile.userData.pos[1];
				var targetLay = targetTile.userData.pos[2];

				var deltaRow = Math.abs(startRow - targetRow);
				var deltaCol = Math.abs(startCol - targetCol);
				var deltaLay = Math.abs(startLay - targetLay);

				//check if move is within range
				if(deltaRow > 1 || deltaCol > 1 || deltaLay > 1) {
					isTargetNotAdjacent = true;
				}

				//no range limit in placement phase
				if(gameState == 0) {
					isTargetNotAdjacent = false;
				}

				//check if a move is left
				if(gameState == 1 && availableMovesRed == 0) {
					noMovesLeft = true;
				} else if(gameState == 2 && availableMovesBlue == 0) {
					noMovesLeft = true;
				}

				//check if another playerblock is in the way
				for (var i = 0; i < playerBlockedTiles.length; i++) {
					if(targetRow == playerBlockedTiles[i][0] && targetCol == playerBlockedTiles[i][1] && targetLay == playerBlockedTiles[i][2]) {
						isTargetBlockedByPlayer = true;
					}
				}

				//sum up flags
				if(isTargetBlockedByPlayer || isTargetNotAdjacent || noMovesLeft) {
					console.log('isTargetBlockedByPlayer: ', isTargetBlockedByPlayer, 'isTargetNotAdjacent: ', isTargetNotAdjacent, 'noMovesLeft: ', noMovesLeft);
					allValid = false;
				}

				return allValid;
			}

			function updateGameMessage(id) {
				gameMessageDomObject.html(gameMessages[id]);
			}

			function onDocumentMouseMove( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}

			function animate() {
				requestAnimationFrame( animate );
				stats.begin();
				render();
				stats.end();
			}

			var dropInterval = 1;
			var increment = 0;

			function render() {
				increment++

				if (increment / dropInterval == 1) {
					increment = 0;

					// find intersections
					raycaster.setFromCamera( mouse, camera );
					var intersects = raycaster.intersectObjects( scene.children );
						if (intersects.length > 0) {
							if (INTERSECTED != intersects[0].object ) {
								if (INTERSECTED) {
									if(INTERSECTED.material.emissive) {
										INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
									}
								}

								INTERSECTED = intersects[0].object;
								currentGameObject = INTERSECTED;

								if(INTERSECTED.material.emissive) {
									INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
									INTERSECTED.material.emissive.setHex(0xff0000);
								}

							}
						} else {
							if (INTERSECTED) {
								if(INTERSECTED.material.emissive) {
									INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
								}
							}
							INTERSECTED = null;
							currentGameObject = null;
						}
					renderer.render( scene, camera );
				}
			}

		</script>

	</body>
</html>
